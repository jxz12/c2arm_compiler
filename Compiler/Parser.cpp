// Generated by Bisonc++ V2.4.8 on Tue, 25 Feb 2014 16:52:58 +0000

    // Include this file in the sources of the class Parser.

// $insert class.h
#include "Parser.h"

using namespace std;

//creates labels with an incrementing suffix to disambiguate
string Parser::createLabel(){
    label_no++;
    return "label" + convert<string>(label_no);
}







///////////////
//STACK_TRACK//
///////////////

//sets the array of bools used for registers as false
void Parser::setRegUsedFalse(){
	for(int i = 0; i < 13; i++){
		current_reg->registers_used[i] = false;
	}
}

//finds a free register, looks from r1 and up to separate variables and temporaries
int Parser::findVarReg(){
	int i;
	for(i = 4; i < 13; i++){
		if(current_reg->registers_used[i] == false){
			current_reg->registers_used[i] = true;
			return i;
		}
	}
	error_list.push_back("line " + convert<string>(lexer.lineno()) + ": ran out of variable registers"); return -1; 
}

//finds a free register, looks from r12 and down to separate variables and temporaries
string Parser::findTempReg(){
	int j;
	for(j = 12; j > 3; j--){
		if(current_reg->registers_used[j] == false){
			current_reg->registers_used[j] = true;
			return convert<string>(j);
		}
	}
	error_list.push_back("line " + convert<string>(lexer.lineno()) + ": ran out of temporary registers"); return "-1";
}





/////////
//SCOPE//
/////////

//adds a variable to a vector without including it's type yet
void Parser::addVariableNoType(s_info token, int array_size){
    variable_info temp;

    //type is temporarily set to an empty string because type is only available further up the tree
    temp.type = "";
    temp.reg = findVarReg();
    temp.array_size = array_size;
    temp.scope_no = current_scope->scope_no;

    if(token.type == "pointer") temp.pointer = true;
    else temp.pointer = false;
    
    //check if name is available
    if(current_scope->variable_map.find(token.value) == current_scope->variable_map.end()){
        current_scope->variable_map[token.value] = temp;
    }
	else{
	    error_list.push_back("line " + convert<string>(lexer.lineno()) + ": variable name '" + token.value + "' already defined in current scope"); return;
	}
}

bool Parser::checkType(string type){
    bool match = false;
    for(map<string, t_info>::const_iterator it = type_map.begin();
        it != type_map.end(); ++it){

        if(it->first == type){
            match = true;
            break;
        }
    }
    return match;
}

//adds the type to the variables declared
void Parser::addVariableType(string type){

    if(!checkType(type)){
    	error_list.push_back("line " + convert<string>(lexer.lineno()) + ": type '" + type + "' not found"); return;
    }

    //check if type is pointer already
    bool pointer = false;
    if(type_map[type].pointer){
        pointer = true;
    }
	for(int i = 0; i < temp_strings.size(); i++){
        if(current_scope->variable_map[temp_strings[i]].pointer && pointer){
            error_list.push_back("line " + convert<string>(lexer.lineno()) + ": type '" + type + "' is already a pointer, pointers to pointers are not supported"); return; 
        }
        current_scope->variable_map[temp_strings[i]].pointer = pointer || current_scope->variable_map[temp_strings[i]].pointer;
	    current_scope->variable_map[temp_strings[i]].type = type;
	}
}

variable_info Parser::getVariableInfo(string name){
	
    scope* temp_scope = current_scope;

	//check if the name exists in the current scope
	do{
		if(temp_scope->variable_map.find(name) == temp_scope->variable_map.end()){
		
			//if not found, go up a scope
			temp_scope = temp_scope->scope_above;
		}
		else{
			return temp_scope->variable_map[name];
		}
	}
	//keep going up scopes until no above scope exists
	while(temp_scope->scope_above != NULL);
	
	//if not found, return error
	variable_info temp = {"", -1};
	error_list.push_back("line " + convert<string>(lexer.lineno()) + ": variable '" + name + "' not defined in current scope"); return temp;
}

//finds the register that a token's information is stored in
string Parser::getRegNo(s_info token){
	if(token.type == "variable"){
		return convert<string>(getVariableInfo(token.value).reg);
	}
	else if(token.type == "temporary"){
		return token.value;
	}
}

//prints the map of variables stored
void Parser::printVariables(map<string, variable_info> variable_map){
        
    for(map <string, variable_info>::const_iterator it = variable_map.begin();
        it != variable_map.end(); ++it){
        
        arm << "name:" << it->first << ", type:" << it->second.type <<  ", reg:" << it->second.reg << ", array_size:" << it->second.array_size;
        if(it->second.pointer) arm << ", pointer";
        arm << endl;
    }
}

//prints a vector of strings received
void Parser::printList(vector<string> list){
    for(int i = 0; i < list.size(); i++){
            arm << list[i] << endl;
    }
}







///////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////




////////////////////
//ARM INSTRUCTIONS//
////////////////////

//clear registers_used for all registers past the variables stored
void Parser::removeUsedTemp(){
    for(int i = current_scope->variable_map.size() + 4; i < 13; i++){
        current_reg->registers_used[i] = false;
        
        //gets rid of any temporaries that shouldn't be in the pointer map
        if(pointer_map.find(i) != pointer_map.end()){
        	pointer_map.erase(i);
        }
    }
}

//remove a temporary's register if passed to this function
void Parser::removeUsedTemp(s_info token){
	if(token.type == "temporary"){
		current_reg->registers_used[convert<int>(token.value)] = false;
	}
}

//overload the function because only 2 temporaries will ever be used in an arm instruction
void Parser::removeUsedTemp(s_info token1, s_info token2){
	if(token1.type == "temporary"){
		current_reg->registers_used[convert<int>(token1.value)] = false;
	}
	if(token2.type == "temporary"){
		current_reg->registers_used[convert<int>(token2.value)] = false;
	}
}

string Parser::MOV(s_info Rd, s_info Op2){

    string text;

	text = "\tMOV" + condition + " r" + getRegNo(Rd) + ", ";
	
	if(Op2.type == "number"){
		text += "#" + Op2.value; 
	}
	else{
		text += "r" + getRegNo(Op2);

        //if a pointer is in the register MOVed from, mark it as also in the place MOVed to
        if(pointer_map.find(convert<int>(getRegNo(Op2))) != pointer_map.end()){
            pointer_map[convert<int>(getRegNo(Rd))] = pointer_map[convert<int>(getRegNo(Op2))];
        }
	}
	text += "\n";
	
	removeUsedTemp(Op2);
    
    return text;
}

//moves the value in a token into a temporary register for when an instruction can't use #number in an argument 
void Parser::convertToTemporary(s_info &token){
    s_info temp = {"temporary", findTempReg()};
    arm << MOV(temp, token);
    token = temp;
}

string Parser::convertToTemporaryNoPrint(s_info &token){
	s_info temp = {"temporary", findTempReg()};
	string text = MOV(temp, token);
	token = temp;
	return text;
}

string Parser::ORR(s_info Rd, s_info Rn, s_info Op2){
    string text;
	text = "\tORR" + condition + " r" + getRegNo(Rd) + ", r" + getRegNo(Rn);
    if(Op2.type == "variable" || Op2.type == "temporary"){
        text += ", r" + getRegNo(Op2);
    }
    else if(Op2.type == "number"){
       text += ", #" + Op2.value;
    }
    text += "\n";
    removeUsedTemp(Rn, Op2);
    return text;
}

string Parser::XOR(s_info Rd, s_info Rn, s_info Op2){
    string text;
	text = "\tXOR" + condition + " r" + getRegNo(Rd) + ", r" + getRegNo(Rn);
    if(Op2.type == "variable" || Op2.type == "temporary"){
        text += ", r" + getRegNo(Op2);
    }
    else if(Op2.type == "number"){
       text += ", #" + Op2.value;
    }
    text += "\n";
    removeUsedTemp(Rn, Op2);
    return text;
}

string Parser::AND(s_info Rd, s_info Rn, s_info Op2){
    string text;
	text = "\tAND" + condition + " r" + getRegNo(Rd) + ", r" + getRegNo(Rn);
    if(Op2.type == "variable" || Op2.type == "temporary"){
        text += ", r" + getRegNo(Op2);
    }
    else if(Op2.type == "number"){
       text += ", #" + Op2.value;
    }
    text += "\n";
    removeUsedTemp(Rn, Op2);
    return text;
}

string Parser::ADD(s_info Rd, s_info Rn, s_info Op2){
    string text;
	text = "\tADD" + condition + " r" + getRegNo(Rd) + ", r" + getRegNo(Rn);
    if(Op2.type == "variable" || Op2.type == "temporary"){
        text += ", r" + getRegNo(Op2);
    }
    else if(Op2.type == "number"){
       text += ", #" + Op2.value;
    }
    text += "\n";
    removeUsedTemp(Rn, Op2);
    return text;
}

string Parser::ADD(s_info Rd, s_info Rn, s_info Op2, int LSL){
    string text;
	text = "\tADD" + condition + " r" + getRegNo(Rd) + ", r" + getRegNo(Rn)
                   + ", r" + getRegNo(Op2) + ", LSL #" + convert<string>(LSL)
                   + "\n";
    removeUsedTemp(Op2);
    return text;
}
    

string Parser::SUB(s_info Rd, s_info Rn, s_info Op2){
    string text;
	text = "\tSUB" + condition + " r" + getRegNo(Rd) + ", r" + getRegNo(Rn);
    if(Op2.type == "variable" || Op2.type == "temporary"){
        text += ", r" + getRegNo(Op2);
    }
    else if(Op2.type == "number"){
       text += ", #" + Op2.value;
    }
    text += "\n";
    removeUsedTemp(Rn, Op2);
    return text;
}

string Parser::MUL(s_info Rd, s_info Rn, s_info Rm){
    string text;
	text = "\tMUL" + condition + " r" + getRegNo(Rd) + ", r" + getRegNo(Rn)
	               + ", r" + getRegNo(Rm) + "\n";
	removeUsedTemp(Rn, Rm);
    return text;
}

string Parser::SDIV(s_info Rd, s_info Rn, s_info Rm){
    string text;
	text = "\tSDIV" + condition + " r" + getRegNo(Rd) + ", r" + getRegNo(Rn)
                    + ", r" + getRegNo(Rm) + "\n";
    removeUsedTemp(Rn, Rm);
    return text;
}

string Parser::CMP(s_info Rn, s_info Op2){
    string text;
    text = "\tCMP" + condition + " r" + getRegNo(Rn) + ", ";
	if(Op2.type == "number"){
		text += "#" + Op2.value;
	}
	else{
		text += "r" + getRegNo(Op2);
	}
	text += "\n";
    return text;
}

string Parser::B(string condition, string label){
    string text;
    text = "\tB" + condition + " " + label + "\n";
    return text;
}

string Parser::BL(string condition, string label){
    string text;
    text = "\tBL" + condition + " " + label + "\n";
    return text;
}

string Parser::PUSH(string reglist){
    string text;
    text = "\tPUSH" + condition + " {" + reglist + "}" + "\n";
    return text;
}

string Parser::POP(string reglist){
    string text;
    text = "\tPOP" + condition + " {" + reglist + "}" + "\n";
    return text;
}



string Parser::LDR(s_info R1, s_info R2, string name){
	string text;
	if(R2.type == "string"){
        //add to the map of registers pointing to registers
        if(R2.value.substr(0,5) != "print" && getVariableInfo(name).array_size == 0)
        	pointer_map[convert<int>(getRegNo(R1))] = getVariableInfo(name).reg;
        	

	    text = "\tLDR" + condition + " r" + getRegNo(R1) + ", " + R2.value + "\n";
	}
	else{
	    text = "\tLDR" + condition + " r" + getRegNo(R1) + ", [r" + getRegNo(R2) + "]\n";
	}
	return text;
}

//overload LDR for arrays to use an offset
string Parser::LDR(s_info R1, s_info R2, s_info offset){
    string text;
    if(offset.type == "number"){
        text = "\tLDR" + condition + " r" + getRegNo(R1) + ", [r" + getRegNo(R2)
                       + ", #" + convert<string>(convert<int>(offset.value) * type_map[current_scope->variable_map[R2.value].type].size) + "]\n";
    }
    else{
        text = "\tLDR" + condition + " r" + getRegNo(R1) + ", [r" + getRegNo(R2)
                       + ", r" + getRegNo(offset)
                                                     //take logs to find LSL value to get the correct byte offset
                       + ", LSL #" + convert<string>(log(type_map[getVariableInfo(R2.value).type].size)/log(2)) + "]\n";
    }
    return text;
}

string Parser::STR(s_info &R1, s_info R2){
    string text;
    if(R1.type == "number"){
        convertToTemporary(R1);
    }
        
    if(R2.type == "string"){
        text = "\tSTR" + condition + " r" + getRegNo(R1) + ", " + R2.value + "\n";
    }
    else{
        text = "\tSTR" + condition + " r" + getRegNo(R1) + ", [r" + getRegNo(R2) + "]\n";
    }
    return text;
}

string Parser::STR(s_info &R1, s_info R2, s_info offset){
    string text;
    
    if(R1.type == "number"){
        convertToTemporary(R1);
    }
    if(offset.type == "number"){
        text = "\tSTR" + condition + " r" + getRegNo(R1) + ", [r" + getRegNo(R2)
                       + ", #" + convert<string>(convert<int>(offset.value) * type_map[getVariableInfo(R2.value).type].size) + "]\n";
    }
    else{
        text = "\tSTR" + condition + " r" + getRegNo(R1) + ", [r" + getRegNo(R2)
                       + ", r" + getRegNo(offset) 
                                                     //take logs to find LSL value to get the correct byte offset
                       + ", LSL #" + convert<string>(log(type_map[getVariableInfo(R2.value).type].size)/log(2)) + "]\n";
    }
    return text;
}


void Parser::armPrintf(){
    if(temp_registers[0].type != "string"){ error_list.push_back("line " + convert<string>(lexer.lineno()) + ": first argument of printf is not a string"); return; }

    if(temp_registers.size() > 4){ error_list.push_back("line " + convert<string>(lexer.lineno()) + ": printf with more than 4 arguments is not supported"); return; }
    
    printf_no++;
    word_list.push_back("print_args" + convert<string>(printf_no) + ": .word print_args_str" + convert<string>(printf_no));
    data_list.push_back("print_args_str" + convert<string>(printf_no) + ": .asciz " + temp_registers[0].value);
    
    s_info temp = {"temporary", "0"};
    s_info temp2 = {"string", "print_args" + convert<string>(printf_no)};
    
    arm << LDR(temp, temp2, "");
    
    s_info dest_reg;
    dest_reg.type = "temporary";
    for(int i = 1; i < temp_registers.size(); i++){
        dest_reg.value = convert<string>(i);
        arm << MOV(dest_reg, temp_registers[i]);
    }
    
    arm << BL(condition, "printf");
}

void Parser::armMalloc(){
    if(temp_registers.size() > 1){ error_list.push_back("line " + convert<string>(lexer.lineno()) + ": malloc cannot have more than 1 argument"); return; }

    s_info temp = {"temporary", "0"};
    arm << MOV(temp, temp_registers[0]);

    arm << BL(condition, "malloc");
}


void Parser::armFree(){
    if(temp_registers.size() > 1){ error_list.push_back("line " + convert<string>(lexer.lineno()) + ": free cannot have more than 1 argument"); return; }

    s_info temp = {"temporary", "0"};
    arm << MOV(temp, temp_registers[0]);

    arm << BL(condition, "free");
}



///////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////



/////////
//TYPES//
/////////

void Parser::initialiseTypeMap(){
    t_info temp = {1, false};
    type_map["char"] = temp;
    temp.size = 4;
    type_map["int"] = temp;
}

void Parser::addType(string type, int size, bool pointer){
    if(type_map.find(type) == type_map.end()){
        if(pointer){
            t_info temp = {4, true};
            type_map[type] = temp;
        }
        else{
            t_info temp = {size, false};
            type_map[type] = temp;
        }
    }
    else{
        error_list.push_back("line " + convert<string>(lexer.lineno()) + ": type name '" + type + "' already defined"); return;
    }
}

/*
void Parser::createStruct(string name){
	map<string, t_info> temp_type_map;
	int size = 0;
	for(map<string, variable_info>::const_iterator it = current_scope->variable_map.begin(); it != current_scope->variable_map.end(); ++it){
		temp_type_map[it->first] = type_map[it->second.type];
		size += type_map[it->second.type].size;
	}
	t_info temp = {size, false, temp_type_map};
	type_map[name] = temp;
    return;
}
*/

string Parser::findSizeof(string type){
    return convert<string>(type_map[type].size);
}









//////////////
//ARM MEMORY//
//////////////

string Parser::createWord(string name, int scope_no){
    return "addr_" + name + convert<string>(scope_no) + ": .word " + name + convert<string>(scope_no);
}

//creates a label that allocates memory for a variable
string Parser::createData(string name, int elements, int bytes, int scope_no){

    //if the variable isn't an array, treat it as if it is one with one element
    if(elements == 0){
    	return name + convert<string>(scope_no) + ": .skip " + convert<string>(bytes);
    }
    else{
    	return ".balign " + convert<string>(bytes) + "\n" + name + convert<string>(scope_no) + ": .skip " + convert<string>(elements*bytes);
    }
}


void Parser::addDefinitions(){

    string name;
    int bytes, elements;

    for(map <string, variable_info>::const_iterator it = current_scope->variable_map.begin();
        it != current_scope->variable_map.end(); ++it){
    
        name = it->first;
        elements = it->second.array_size;
        if(current_scope->variable_map[name].pointer){
            //pointers are always 4 byte addresses
            bytes = 4;
        }
        else{
            bytes = type_map[current_scope->variable_map[name].type].size;
        }

        data_list.push_back(createData(name, elements, bytes, current_scope->scope_no));
        word_list.push_back(createWord(name, current_scope->scope_no));
    }

}


string Parser::loadChar(s_info temp, string character){
    string label = "char" + convert<string>(++char_no);
    data_list.push_back(label + ": .byte " + character);
    word_list.push_back("addr_" + label + ": .word " + label);
    s_info address = {"string", "addr_" + label};
    return "\tLDR r" + temp.value + ", addr_" + label + "\n\tLDR r" + temp.value + ", [r" + temp.value + "]\n";
}









/////////////////////
//STORING FUNCTIONS//
/////////////////////

//keeps track of the parameters in a function definition
void Parser::addParameter(string type, s_info token){
	if(temp_variable_map.find(token.value) == temp_variable_map.end()){
		if(!checkType(type)){
    		error_list.push_back("line " + convert<string>(lexer.lineno()) + ": type '" + type + "' not found"); return;
    	}
		variable_info temp;
		temp.type = type;
		temp.reg = temp_count++;
        temp.array_size = 0;
        
        //add 1 to scope_no because the curly bracket hasn't been seen yet
        temp.scope_no = current_scope->scope_no + 1;
        if(token.type == "pointer") temp.pointer = true;
        else temp.pointer = false;

		temp_variable_map[token.value] = temp;
	}
	else{
		error_list.push_back("line " + convert<string>(lexer.lineno()) + ": function parameter '" + token.value + "' already defined"); return;
	}
}

//stores the name, return type, parameters needed of a function in a map
void Parser::storeFunction(string name, string return_type, bool prototype){
	//if the name hasn't been seen before, add it to the map
	if(function_map.find(name) == function_map.end()){
		function_info temp;
		temp.return_type = return_type;
		temp.defined = !prototype;
		temp.parameter_map = temp_variable_map;
		function_map[name] = temp;
	}
	
	//if the definition has already been created and another is attempted
	else if(function_map[name].defined && !prototype){
		error_list.push_back("line " + convert<string>(lexer.lineno()) + ": function '" + name + "' already defined"); return;
	}
	
	//if a function of the same name as a protoype has been created, do nothing, but set the defined flag to true
	else if(function_map.find(name) != function_map.end() && !prototype){
		function_map[name].defined = true;
		return;
	}
	
}






/////////////////////
//CALLING FUNCTIONS//
/////////////////////

void Parser::procedureCall(string name){

    //temp_registers contains a list of the registers that contain the functions parameters
    //move the parameters used to the right place (registers 0 to 3)
    
    s_info dest_reg;
    dest_reg.type = "temporary";
    
    if(temp_registers.size() < 5){
        for(int i = 0; i < temp_registers.size(); i++){
            dest_reg.value = convert<string>(i);
            arm << MOV(dest_reg, temp_registers[i]);
        }
        arm << BL(condition, name);
    }
    
    //if there are more than 4 parameters then the stack is needed
    else if(temp_registers.size() == 5){
        arm << PUSH("r4");
        
        for(int i = 0; i < temp_registers.size(); i++){
            dest_reg.value = convert<string>(i);
            arm << MOV(dest_reg, temp_registers[i]);
        }
        arm << BL(condition, name);
        arm << POP("r4");
    }
    else if(temp_registers.size() > 5){
        arm << PUSH("r4-r" + convert<string>(temp_registers.size() - 1));
        
        for(int i = 0; i < 4; i++){
            dest_reg.value = convert<string>(i);
            arm << MOV(dest_reg, temp_registers[i]);
        }
        
        //move the rest into temporary registers first to prevent data hazards
        vector<s_info> temp_list;
        for(int i = 4; i < temp_registers.size(); i++){
            dest_reg.value = findTempReg();
            arm << MOV(dest_reg, temp_registers[i]);
            temp_list.push_back(dest_reg);
        }
        for(int i = 0; i < temp_list.size(); i++){
            dest_reg.value = convert<string>(i+4);
            arm << MOV(dest_reg, temp_list[i]);
        }
        arm << BL(condition, name);
        arm << POP("r4-r" + convert<string>(temp_registers.size() - 1));
    }
}





void Parser::functionCall(string name){
    if(name == "printf"){
		if(headers.find("stdio.h") == -1){
			error_list.push_back("line " + convert<string>(lexer.lineno()) + ": printf called but stdio.h not included"); return;
		}
        armPrintf();
    }
    else if(name == "malloc"){
		if(headers.find("stdlib.h") == -1){
			error_list.push_back("line " + convert<string>(lexer.lineno()) + ": malloc called but stdlib.h not included"); return;
		}
        armMalloc();
    }
    else if(name == "free"){
		if(headers.find("stdlib.h") == -1){
			error_list.push_back("line " + convert<string>(lexer.lineno()) + ": free called but stdlib.h not included"); return;
		}
        armFree();
    }
    else{
        //if the function hasn't been defined
    	if(function_map.find(name) == function_map.end()){
        	error_list.push_back("line " + convert<string>(lexer.lineno()) + ": function '" + name + "' not previously defined"); return;
    	}
    	//if only a prototype has been defined
    	if(function_map[name].defined = false){
    	    error_list.push_back("line " + convert<string>(lexer.lineno()) + ": function '" + name + "' not previously defined"); return;
    	}
    	//if the amount of parameters isn't correct
    	if(function_map[name].parameter_map.size() != temp_registers.size()){
    	    error_list.push_back("line " + convert<string>(lexer.lineno()) + ": incorrect number of parameters in function '" + name + "'"); return;
    	}
        procedureCall(name);
    }
}





//concatenates the values of a vector of temporary registers because I need to pass the value of multiple registers in one token
string Parser::concatenateRegisters(vector<s_info> temp_registers){
	string registers;
	for(int i = 0; i < temp_registers.size(); i++){
		registers += getRegNo(temp_registers[i]) + " ";
    }
    return registers;
}

//gets the vector of temporary registers back
vector<s_info> Parser::unconcatenateRegisters(string registers){
	vector<s_info> temp_registers;
	string temp;
	s_info reg;
	reg.type = "temporary";
	for(string::const_iterator it = registers.begin(); it != registers.end(); ++it){
		if(*it == ' '){
			reg.value = temp;
			temp_registers.push_back(reg);
			temp.clear();
		}
		else{
			temp += *it;
		}
	}
	return temp_registers;
}







/////////////////
//FUNCTION CODE//
/////////////////

void Parser::functionCodeStart(string name){
	arm << name << ":" << endl;
	//sets the variable_map to the parameter_map
	current_scope->variable_map = function_map[name].parameter_map;
	current_function = name;
	
	//push the values needed after the function onto the stack
	arm << PUSH("r4-r12, lr");
	stack_track* temp = new stack_track;
	temp->stack_above = current_reg;
	current_reg = temp;
	
	int i = current_scope->variable_map.size() + 3;
	s_info parameter = {"variable", ""},
		   parameter_dest = {"temporary", ""},
		   temp_reg = {"temporary", findTempReg()};
		   
	//set up the state of the program
	for(map<string, variable_info>::iterator it = current_scope->variable_map.end();
		it != current_scope->variable_map.begin(); ){
		--it;
        
        //move the parameters (starting from r0) into r4 upwards so that they act like normal variables
		parameter.value = it->first;
		parameter_dest.value = convert<string>(i);
		arm << MOV(parameter_dest, parameter);
		it->second.reg = i;
		current_reg->registers_used[i] = true;
		i--;
		
		//STR all the variables in their memory locations (essentially copying when passed by value)
	    s_info variable = {"variable", it->first},
	           address = {"string", "addr_" + it->first + convert<string>(getVariableInfo(it->first).scope_no)};
	           
        arm << LDR(temp_reg, address, it->first) + STR(variable, temp_reg);
	}
	removeUsedTemp(temp_reg);
}

void Parser::functionCodeEnd(){
	//just in case there's no return statement
	arm << POP("r4-r12, pc") << endl;
    current_function = "";
    
    //move the state of the popped stack back into current_reg
    stack_track* temp = current_reg;
    current_reg = current_reg->stack_above;
    delete temp;
}







/////////////
//OPERATORS//
/////////////

//returns the instruction for each math operator
string Parser::mathOp(string op, s_info &Rd, s_info &Rn, s_info &Op2){
	string text;

    //create a temporary register if a number is used in Rn
    if(Rn.type == "number") text += convertToTemporaryNoPrint(Rn);
           	
	//create a temporary register for the result
	Rd.value = findTempReg();
	Rd.type = "temporary"; 

    //bitwise
    if(op == "|") return text + ORR(Rd, Rn, Op2);
    if(op == "^") return text + XOR(Rd, Rn, Op2);
    if(op == "&") return text + AND(Rd, Rn, Op2);

    //math
    if(op == "+") return text + ADD(Rd, Rn, Op2);
    if(op == "-") return text + SUB(Rd, Rn, Op2);
    if(op == "*"){
        //create a temporary register if a number is used in Op2(Rm) for multiply and divide
        if(Op2.type == "number") text += convertToTemporaryNoPrint(Op2);
        return text + MUL(Rd, Rn, Op2);
    }
    if(op == "/"){
        if(Op2.type == "number") text += convertToTemporaryNoPrint(Op2);
        return text + SDIV(Rd, Rn, Op2);
    }

}





//finds the condition codes for each comparator
string Parser::findConditionCode(string op){
    if(op == "==") return "EQNE";
    if(op == "!=") return "NEEQ";
    if(op == "<")  return "LTGE";
    if(op == "<=") return "LEGT";
    if(op == ">")  return "GTLE";
    if(op == ">=") return "GELT";
}



string Parser::compareOp(string op, s_info &Rd, s_info &Rn, s_info Op2){
    string text;
    //create a temporary register if a number is used in Rn
    if(Rn.type == "number"){
       	text += convertToTemporaryNoPrint(Rn);
    }
	//create a temporary register for the result
	Rd.value = findTempReg();
	Rd.type = "temporary";

    text += CMP(Rn, Op2);
    condition = findConditionCode(op).substr(0,2);
    s_info temp = {"number", "1"};
    text += MOV(Rd, temp);
    condition = findConditionCode(op).substr(2,2);
    temp.value = "0";
    text += MOV(Rd, temp);
    condition.clear();
    return text;
}







string Parser::logicalOp(string op, s_info &Rd, s_info Rn, s_info Op2){

    s_info temp = {"number", "0"};
    string text = CMP(Rn, temp);
    if(op == "&&"){
        //compare if the left expression does return true, so it has to go through both
        condition = "NE";
        text += CMP(Op2, temp);
    }
    if(op == "||"){
        //only compare if the left expression one doesn't return true, so it skips the right if the left is already true
        condition = "EQ";
        text += CMP(Op2, temp);
    }
    condition = "NE";
    temp.value = "1";
    return text + MOV(Rd, temp);
}











///////////////
//ASSIGNMENTS//
///////////////


//retrieves the register that the variable a pointer is pointing at is stored in so that it can be updated
s_info Parser::getPointedReg(s_info token){
    s_info temp = {"temporary", convert<string>(pointer_map[getVariableInfo(token.value).reg])};
    return temp;
}

s_info Parser::getArrayPointedReg(string mem_location){
    s_info temp = {"temporary", convert<string>(array_pointer_map[mem_location])};
    return temp;
}

//dereferences a pointer
s_info Parser::loadDereference(s_info token){
    s_info temp;
    temp.type = "temporary";
    temp.value = findTempReg();
    token.type = "variable";
    arm << LDR(temp, token, token.value);
    return temp;
}


string Parser::createAssignment(s_info left, s_info &right){

    //if the left hand side is a derefenced pointer
    if(left.type == "pointer"){
        if(!getVariableInfo(left.value).pointer){
            error_list.push_back("line " + convert<string>(lexer.lineno()) + ": variable '" + left.value + "' dereferenced but is not a pointer"); return "";
        }
        if(right.type == "number" || right.type == "char"){
            convertToTemporary(right);
        }
        s_info temp = {"variable", left.value};
        if(pointer_map.find(getVariableInfo(left.value).reg) == pointer_map.end()) return STR(right, temp);
        else return STR(right, temp) + MOV(getPointedReg(left), right);
    }
    else{
        s_info address = {"string", "addr_" + left.value + convert<string>(getVariableInfo(left.value).scope_no)};
        s_info temp = {"temporary", findTempReg()};
        return MOV(left, right) + LDR(temp, address, left.value) + STR(left, temp);
    }
}


//overload createAssignment for arrays
string Parser::createAssignment(s_info left, s_info &right, s_info offset){

	if(getVariableInfo(left.value).pointer == false || getVariableInfo(left.value).array_size == 0)
		error_list.push_back("line " + convert<string>(lexer.lineno()) + ": variable '" + left.value + "' indexed with [] but is not a pointer or array");
		
    if(right.type == "number" || right.type == "char"){
        convertToTemporary(right);
    }
    //if the left hand side is a derefenced pointer
    if(left.type == "pointer"){
        if(!getVariableInfo(left.value).pointer){
            error_list.push_back("line " + convert<string>(lexer.lineno()) + ": variable '" + left.value + "'dereferenced but is not a pointer"); return "";
        }
        s_info temp = {"temporary", findTempReg()};
        left.type = "variable";

        string mem_location = getRegNo(left) + offset.value;
        if(array_pointer_map.find(mem_location) == array_pointer_map.end()) return LDR(temp, left, offset) + STR(right, temp);
        else return LDR(temp, left, offset) + STR(right, temp) + MOV(getArrayPointedReg(mem_location), right);
    }
    else{
        //if a pointer is in the register STRed from, mark it as also in the place MOVed to
        if(pointer_map.find(convert<int>(getRegNo(right))) != pointer_map.end()){
            array_pointer_map[getRegNo(left) + offset.value] = pointer_map[convert<int>(getRegNo(right))];
        }
        return STR(right, left, offset);
    }
}



//overload createAssignment for ++ and --
string Parser::createAssignment(s_info left, string op){

	string instruction;
    s_info one = {"number", "1"};
	
	if(left.type == "pointer"){
        if(!getVariableInfo(left.value).pointer){
            error_list.push_back("line " + convert<string>(lexer.lineno()) + ": variable '" + left.value + "'dereferenced but is not a pointer"); return "";
        }
	    s_info temp = {"temporary", findTempReg()};
	    instruction += LDR(temp, left, "");
        
        if(op == "++"){
        	instruction += ADD(temp, temp, one);
        }
        if(op == "--"){
        	instruction += SUB(temp, temp, one);
        }
        s_info temp2 = {"variable", left.value};
        if(pointer_map.find(getVariableInfo(left.value).reg) == pointer_map.end()) return instruction + STR(temp, temp2);
        else return instruction + STR(temp, temp2) + MOV(getPointedReg(left), temp);
    }
    else{
    	if(op == "++"){
        	instruction += ADD(left, left, one);
        }
        if(op == "--"){
        	instruction += SUB(left, left, one);
        }
        
        s_info address = {"string", "addr_" + left.value + convert<string>(getVariableInfo(left.value).scope_no)};
        s_info temp = {"temporary", findTempReg()};
        return instruction + LDR(temp, address, left.value) + STR(left, temp);
    }
}





