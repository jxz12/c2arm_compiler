// Generated by Bisonc++ V2.4.8 on Thu, 20 Feb 2014 21:08:46 +0000

#ifndef Parser_h_included
#define Parser_h_included

// $insert baseclass
#include "Parserbase.h"

#include <FlexLexer.h>
#include "Util.h"
#include <fstream>

#undef Parser

using namespace std;

class Parser: public ParserBase
{
	public:
        int parse();
        Parser() : temp_count(0), returned_yet(false), label_no(0), scope_no(0), printf_no(0), char_no(0), arm("test.s") {}
        ~Parser(){ 
        	arm.close(); 
        	//print out any errors found
            for(int i = 0; i < error_list.size(); i++) cout << error_list[i] << endl;
        }
        
        //variables
        
        ofstream arm;
        //data to keep track of information that's needed further up the parse tree
		vector<s_info> temp_registers;
		vector<string> temp_strings;
		string temp_expression;
		string temp_assignment;
		map<string, variable_info> temp_variable_map;
		int temp_count;
		//maps to keep track of defined types and functions
		map<string, t_info> type_map;
		map<string, function_info> function_map;
		//map to keep track of registers that other registers are pointed at
		map<int, int> pointer_map;
		map<string, int> array_pointer_map;
		//string to keep track of condition code set
		string condition;
		//keep track of the current function being defined and if it has been returned yet
		string current_function;
		bool returned_yet;
		//ints to disambiguate labels
		int label_no;
		int scope_no;	
		int printf_no;
		int char_no;
		//linked lists to keep track of variables and registers
		scope* current_scope;
		stack_track* current_reg;	
		//vectors of strings to store text that needs to be printed only at the end
		vector<string> word_list;
		vector<string> data_list;
		vector<string> error_list;
		//a string to keep track of what header files have been included
		string headers;
		
		
		//functions
		
		string createLabel();
		///////////////
		//STACK_TRACK//
		///////////////
		void setRegUsedFalse();
		int findVarReg();
		string findTempReg();
		/////////
		//SCOPE//
		/////////
		void addVariableNoType(s_info token, int array_size);
		bool checkType(string type);
		void addVariableType(string type);
		variable_info getVariableInfo(string name);
		string getRegNo(s_info token);
		void printVariables(map<string, variable_info> variable_map);
		void printList(vector<string> list);
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////
		////////////////////
		//ARM INSTRUCTIONS//
		////////////////////
		void removeUsedTemp();
		void removeUsedTemp(s_info token);
		void removeUsedTemp(s_info token1, s_info token2);
		string MOV(s_info Rd, s_info Op2);
		void convertToTemporary(s_info &token);
		string convertToTemporaryNoPrint(s_info &token);
		string ORR(s_info Rd, s_info Rn, s_info Op2);
		string XOR(s_info Rd, s_info Rn, s_info Op2);
		string AND(s_info Rd, s_info Rn, s_info Op2);
		string ADD(s_info Rd, s_info Rn, s_info Op2);
		string ADD(s_info Rd, s_info Rn, s_info Op2, int LSL);
		string SUB(s_info Rd, s_info Rn, s_info Op2);
		string MUL(s_info Rd, s_info Rn, s_info Rm);
		string SDIV(s_info Rd, s_info Rn, s_info Rm);
		string CMP(s_info Rn, s_info Op2);
		string B(string condition, string label);
		string BL(string condition, string label);
		string PUSH(string reglist);
		string POP(string reglist);
		string LDR(s_info R1, s_info R2, string name);
		string LDR(s_info R1, s_info R2, s_info offset);
		string STR(s_info &R1, s_info R2);
		string STR(s_info &R1, s_info R2, s_info offset);
		void armPrintf();
		void armMalloc();
		void armFree();
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/////////
		//TYPES//
		/////////
		void initialiseTypeMap();
		void addType(string type, int size, bool pointer);
		void createStruct(string name);
		string findSizeof(string type);
		//////////////
		//ARM MEMORY//
		//////////////
		string createWord(string name, int scope_no);
		string createData(string name, int elements, int bytes, int scope_no);
		void addDefinitions();
		string loadChar(s_info temp, string character);
		/////////////////////
		//STORING FUNCTIONS//
		/////////////////////
		void addParameter(string type, s_info token);
		void storeFunction(string name, string return_type, bool prototype);
		/////////////////////
		//CALLING FUNCTIONS//
		/////////////////////
		void procedureCall(string name);
		void functionCall(string name);
		string concatenateRegisters(vector<s_info> temp_registers);
		vector<s_info> unconcatenateRegisters(string registers);
		/////////////////
		//FUNCTION CODE//
		/////////////////
		void functionCodeStart(string name);
		void functionCodeEnd();
		/////////////
		//OPERATORS//
		/////////////
		string mathOp(string op, s_info &Rd, s_info &Rn, s_info &Op2);
		string findConditionCode(string op);
		string compareOp(string op, s_info &Rd, s_info &Rn, s_info Op2);
		string logicalOp(string op, s_info &Rd, s_info Rn, s_info Op2);
		///////////////
		//ASSIGNMENTS//
		///////////////
		s_info getPointedReg(s_info token);
		s_info getArrayPointedReg(string mem_location);
		s_info loadDereference(s_info token);
		string createAssignment(s_info left, s_info &right);
		string createAssignment(s_info left, s_info &right, s_info offset);
		string createAssignment(s_info left, string op);



    private:
	yyFlexLexer lexer;
        void error(char const *msg);    // called on (syntax) errors
        int lex();                      // returns the next token from the
                                        // lexical scanner. 
        void print();                   // use, e.g., d_token, d_loc

    // support functions for parse():
        void executeAction(int ruleNr);
        void errorRecovery();
        int lookup(bool recovery);
        void nextToken();
};

inline int Parser::lex() {
  return lexer.yylex();
}

inline void Parser::error(char const *msg)
{
    std::cerr << "line " << lexer.lineno() << ": " << msg << std::endl;
}

// $insert lex

inline void Parser::print()      // use d_token, d_loc
{}




#endif
